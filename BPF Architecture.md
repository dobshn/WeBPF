BPF는 명령어 집합을 제공할 뿐만아니라, map과 같은 추가적인 인프라도 제공한다.

LLVM을 통해 `clang`과 같은 도구를 사용하여 C 코드를 BPF 오브젝트로 컴파일할 수 있다. 컴파일된 오브젝트 파일은 이후 커널에 로드되어 실행된다.

커널 시스템중 tc, XDP는 BPF를 활용한다. 이들도 BPF 인프라의 일부다. BPF 프로그램은 이들에 부착될 수 있다.
- **XDP BPF** 네트워크 드라이버의 가장 초기에 부착된다. 따라서 가장 빠른 성능을 낼 수 있다. 하지만 네트워크 스택이 패킷 메타데이터를 추출하기 전이라 활용할 수 있는 데이터가 적다.
- **tc BPF** XDP보다 더 나중에 실행되기 때문에 더 많은 메타데이터와 커널 기능에 접근할 수 있다.

### Instruction Set

**Spilling**: 레지스터의 값을 스택에 옮기는 것
**Filling**: BPF 스택에서 레지스터로 값을 옮기는 것

레지스터 `r1`에는 프로그램의 인자가 들어간다.

BPF의 일반 연산은 64 bits다.

BPF 프로그램은 최대 4096개의 BPF 명령어로 제한되어있다. 하지만 Linux kernel 5.1 이상에서는 100만 개의 명령어로 제한이 상향되었다.

다른 BPF 프로그램으로 넘어갈 수 있는 tail call이 존재하지만, 이도 33단계의 호출까지 제한되어 있다.

모든 BPF 명령어는 64 bits 고정길이다. 현재 87개의 명령어들이 구현되었다.

명령어 구성:
`op(8) dst_reg(4) src_reg(4) off(16) imm(32)`
- `off`와 `imm`는 signed 타입이다.
- 이는 `linux/bpf_common.h`를 포함하는 `linux/bpf.h`에 포함되어 있다.

`op`는 수행할 연산을 지정한다. 이는 cBPF에서 많이 재사용되었다. 연산은 레지스터 기반일 수도 있고, 즉시값 기반일 수도 있다. 이는 `op` 인코딩에 나타난다.
- `BPF_X`는 레지스터 기반 연산을 의미한다.
- `BPF_K`는 즉시 값 기반 연산을 의미한다.

8 bits의 `op` 필드는 다음과 같이 구분된다.
`code:4, source:1, class:3`
- `class`는 큰 범주의 연산을 구분한다.
- `code`는 `class` 안에서 구체적인 연산을 지정한다.
- `source`는 레지스터 기반인지, 즉시 값 기반인지를 지정한다.

`BPF_LE`, `BPF_LDX`

## Helper Functions
BPF 프로그램이 커널에서 데이터를 가져오고 넣기 위한 커널 함수를 사용하는 통로이다. 사용 가능한 helper function은 BPF 프로그램이 부착되는 위치에 따라 다를 수 있다. 예를 들어, 소켓에 부착된 BPF 프로그램은 tc에 부착된 BPF 프로그램이 사용할 수 있는 helper function의 일부만을 사용할 수 있다.

각 helper function은 공유하는 공통된 함수 원형을 갖는다.
`u64 fn(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)`

함수 호출은 인자 수에 따라 `BPF_CALL_0()`부터 `BPF_CALL_5()`로 이루어진다. 예를 들어, `BPF_CALL_2()`는 인자를 두 개 갖는 helper function을 호출할 때 사용한다. 매크로의 인자는, 첫 번째는 호출할 helper function의 이름이 들어가고, 이후에는 각 인자의 타입과 변수명이 차례로 들어간다.

## Maps
Map은 커널 공간에 존재하는 효율적인 key/value 저장소다. 다른 BPF 프로그램 혹은 사용자 공간에서도 같은 map을 공유할 수 있다.

같은 map을 공유하는 프로그램이 같은 타입일 필요는 없다. 하나의 BPF 프로그램은 최대 64개의 서로 다른 map에 접근할 수 있다.

## Object Pinning
BPF 맵과 프로그램은 커널 자원으로 파일 서술자 기반으로 접근된다. 하지만 파일 서술자는 프로세스 종료시 사라진다. 따라서 프로세스에서 생성한 맵이, 해당 프로세스 종료와 동시에 사라질 수 있다.

이를 해결하는 것이 Object pinning이다. 커널은 최소한의 BPF 전용 가상 파일 시스템을 제공한다. 여기에 BPF 프로그램이나 맵을 pin하여 보존할 수 있다.


## Tail Calls
하나의 BPF 프로그램이 다른 BPF 프로그램을 호출한 뒤 돌아오지 않는 것. 같은 스택 프레임을 재사용하므로 오버헤드가 적음. 호출하는 프로그램끼리는 프로그램 타입과 컴파일 타입이 일치해야 함.
Tail calls의 두 가지 구성 요소
- **program array(BPF_MAP_TYPE_PROG_ARRAY)** 사용자 공간에서 key/value로 채워짐. value는 호출될 프로그램의 파일 서술자.
- **bpf_tail_call() 헬퍼 함수**

## BPF to BPF Calls
BPF 헬퍼와 BPF tail calls 외에 최근 추가된 기능이 BPF에서 BPF로의 함수 호출이다. 이 기능이 도입되기 전까지는 헤더에 정의된 함수들은 항상 `__inline`으로 선언되어야 했고, 이는 코드의 크기를 증가시켰다.

하지만 Linux kernel 4.16, LLVM 6.0 이상부터는 이 제한이 해제되었다. 현재 x86_64 및 arm64에서 이를 지원하며 다른 아키텍처도 지원 예정이다.

## JIT
대부분의 64비트 아키텍처와 일부 32비트 아키텍처는 Linux kernel 내에 eBPF JIT 컴파일러를 내장하고 있다. 이는 다음 명령어로 활성화할 수 있다.

```bash
# echo 1 > /proc/sys/net/core/bpf_jit_enable
```

JIT 컴파일러가 없는 아키텍처들은 in-kernel 인터프리터를 통해 eBPF 프로그램을 실행해야 한다.

JIT 컴파일러는 인터프리터에 비해 명령어당 실행 비용이 적기 때문에 BPF 프로그램의 실행 속도를 크게 향상시킨다.
## Hardening

**메모리 보호**
BPF 프로그램은 커널에 로드될 때 `struct bpf_prog`에 바이트 코드가 저장된다. 이것이 BPF interpreter image이다. 만일 JIT 컴파일러가 존재하는 아키텍처이고 활성화 되어있다면, 바이트코드르를 변환해서 머신코드를 `struct bpf_binary_header`에 저장한다. 이것이 JIT compiled 이미지이다.

BPF 프로그램은 커널에 존재하는 동안 이미지가 읽기 전용으로 잠긴다. 만약 어떤 이유에서든 수정이 일어나면, 이를 허용하지 않고 crash를 발생시킨다.

이러한 메모리 보호 기능은 설정할 수 없고 자동으로 켜져있다. 이를 지원하는 아키텍처는 다음과 같다.
- arm
- arm64
- s390
- x86

`x86_64` JIT 컴파일러에서 `CONFIG_RETPOLINE` 옵션이 켜져있다면 tail call에 사용되는 간접 점프를 retpoline으로 구현한다. 이 옵션은 최신 Linux 버전에선 기본으로 켜져 있다.

`/proc/sys/net/core/bpf_jit_harden` 값을 1로 설정하면 특권이 없는 사용자에 의해 JIT 컴파일이 수행될 시에 추가적인 hardening 조치가 적용된다. 이는 성능을 약간 희생하는 대신 보안을 향상하는 효과가 있다. 이런 경우라도 여전히 인터프리터 방식보다는 빠르다.

hardening이 켜지면, 32 bit와 64 bit 상수는 blind 처리가 된다. 이는 상수를 통한 JIT spraying을 방지하기 위함이다. 이는 즉시 값을 랜덤 값과 xor한 뒤 레지스터에 저장하고, 다시 그 레지스터에 랜덤 값을 xor함으로써 이루어진다.

예를 들어,
```asm
39:   mov    $0xa8909090,%eax
```
과 같은 명령어는 hardening을 통해 다음과 같이 변경된다.
```asm
39:   mov    $0xe1192563,%r10d
3f:   xor    $0x4989b5f3,%r10d
46:   mov    %r10d,%eax
```

또한 hardening이 활성화되면 root에게도 JIT 이미지의 메모리 주소가 `/proc/kallsyms`에 노출되지 않게 된다.

`CONFIG_BPF_JIT_ALWAYS_ON`이라는 커널 설정이 있는데, 이것을 활성화하게되면 커널에서 BPF 인터프리터가 아예 제거되고 JIT 컴파일러만 항상 켜진 채로 동작한다. 이는 인터프리터를 활용한 공격을 예방할 수 있다. JIT이 널리 쓰이는 `x86_64`, `arm64`와 같은 경우에서는 이를 활성화해두는 것이 복잡성도 줄이고 일반적으로 권장된다.

추가로 커널은 `/proc/sys/kernel/unprivileged_bpf_disabled` 설정을 통해 비특권 사용자가 `bpf()` 시스템 콜을 사용하는 것을 막을 수 있는 옵션도 제공한다. 이 설정은 one-way 스위치로, 한 번 활성화 하면 커널을 재부팅하기 전까지는 0으로 되돌릴 수 없다.
## Offloads

일반적으로 BPF 프로그램은 커널에서 실행된다. 하지만 특정 BPF 프로그램은 하드웨어로 옮겨질 수도 있다. 예를 들어, 네트워크 인터페이스 카드에서 직접 BPF 코드가 실행되도록 할 수 있다. 이는 CPU 자원을 아끼고, 네트워크 처리 성능도 향상키시게 된다.

## BPF sysctls

리눅스 커널은 BPF와 관련된 몇 가지 sysctl 설정을 제공한다. `/proc/sys/net/core/bpf_jit_enable`은 BPF JIT 컴파일러의 활성화 여부를 제어하는 옵션으로, 0은 인터프리터만 사용하고, 1은 JIT을 활성화하며, 2는 JIT을 활성화하면서 디버깅 로그를 커널 로그에 출력한다. 이때는 `bpf_jit_disasm` 도구로 디버깅이 가능하다.

`/proc/sys/net/core/bpf_jit_harden`은 보안 강화를 위한 설정으로, BPF 프로그램 내 즉시값을 블라인딩 처리하여 JIT spraying 공격을 방지한다. 0은 비활성화, 1은 비특권 사용자만 적용, 2는 모든 사용자에게 적용된다. 인터프리터로 실행되는 경우엔 이 하드닝은 적용되지 않는다.

`/proc/sys/net/core/bpf_jit_kallsyms`는 JIT된 BPF 프로그램을 커널 심볼(/proc/kallsyms)에 노출할지 설정하는 옵션으로, 퍼포먼스 도구나 스택 트레이스를 위한 디버깅에 활용할 수 있다. 0은 비활성화, 1은 특권 사용자에 한해 노출되며, 하드닝이 켜져 있으면 자동으로 비활성화된다.

마지막으로 `/proc/sys/kernel/unprivileged_bpf_disabled`는 일반 사용자의 bpf() 시스템 콜 사용 여부를 제어한다. 0은 허용(기본값), 1은 한 번 설정하면 재부팅 전까지 영구 차단되며 되돌릴 수 없다. 2는 일시적으로 차단하며 나중에 다시 설정 변경이 가능하다. 